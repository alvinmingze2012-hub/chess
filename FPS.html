<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Military Mobile FPS</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
body {
    margin: 0;
    overflow: hidden;
    background: black;
    touch-action: none;
    font-family: Arial, sans-serif;
}

#hud {
    position: fixed;
    bottom: 15px;
    left: 15px;
    color: #7dd3fc;
    font-size: 16px;
    text-shadow: 0 0 5px black;
    z-index: 10;
}

#crosshair {
    position: fixed;
    left: 50%;
    top: 50%;
    width: 6px;
    height: 6px;
    margin-left: -3px;
    margin-top: -3px;
    background: #7dd3fc;
    border-radius: 50%;
    z-index: 10;
}

.joystick {
    position: fixed;
    bottom: 40px;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.05);
    border: 2px solid rgba(255,255,255,0.15);
    z-index: 10;
}

#leftJoy { left: 30px; }

.stick {
    position: absolute;
    left: 40px;
    top: 40px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(125,211,252,0.85);
}

#shootBtn {
    position: fixed;
    right: 30px;
    bottom: 60px;
    width: 90px;
    height: 90px;
    border-radius: 50%;
    background: rgba(127,29,29,0.75);
    border: 2px solid rgba(255,255,255,0.3);
    color: white;
    font-size: 18px;
    z-index: 10;
}
</style>
</head>

<body>

<div id="crosshair"></div>
<div id="hud">Ammo: <span id="ammo">30</span></div>

<div id="leftJoy" class="joystick">
    <div id="leftStick" class="stick"></div>
</div>

<button id="shootBtn">FIRE</button>

<!-- ✅ NON-MODULE THREE.JS (iOS SAFE) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160/build/three.min.js"></script>

<script>
let scene, camera, renderer;
let enemies = [];
let ammo = 30;

const raycaster = new THREE.Raycaster();
const ammoUI = document.getElementById("ammo");

let move = { x: 0, y: 0 };
let look = { x: 0, y: 0 };

/* ---------- INIT ---------- */
init();
animate();

function init(){
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05070a);

    camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 5);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    /* ✅ LIGHTING (FIXED) */
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 2);
    scene.add(dirLight);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    /* Debug grid (prevents “black world” confusion) */
    scene.add(new THREE.GridHelper(200, 40));

    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 200),
        new THREE.MeshStandardMaterial({ color: 0x111827 })
    );
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    for(let i = 0; i < 20; i++){
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(3, 3, 3),
            new THREE.MeshStandardMaterial({ color: 0x1f2933 })
        );
        box.position.set(
            (Math.random() - 0.5) * 80,
            1.5,
            (Math.random() - 0.5) * 80
        );
        scene.add(box);
    }

    for(let i = 0; i < 6; i++) spawnEnemy();

    initJoystick();
    initLook();

    document.getElementById("shootBtn").addEventListener("pointerdown", e => {
        e.preventDefault();
        shoot();
    });

    window.addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });
}

/* ---------- JOYSTICK ---------- */
function initJoystick(){
    const joy = document.getElementById("leftJoy");
    const stick = document.getElementById("leftStick");
    let rect, center;

    function update(){
        rect = joy.getBoundingClientRect();
        center = { x: rect.width / 2, y: rect.height / 2 };
    }
    update();
    window.addEventListener("resize", update);

    joy.addEventListener("pointerdown", e => {
        joy.setPointerCapture(e.pointerId);
    });

    joy.addEventListener("pointermove", e => {
        if(!joy.hasPointerCapture(e.pointerId)) return;

        const dx = e.clientX - rect.left - center.x;
        const dy = e.clientY - rect.top - center.y;

        const dist = Math.min(40, Math.hypot(dx, dy));
        const ang = Math.atan2(dy, dx);

        stick.style.left = center.x + Math.cos(ang) * dist - 20 + "px";
        stick.style.top  = center.y + Math.sin(ang) * dist - 20 + "px";

        move.x = Math.cos(ang) * (dist / 40);
        move.y = Math.sin(ang) * (dist / 40);
    });

    joy.addEventListener("pointerup", () => {
        stick.style.left = "40px";
        stick.style.top  = "40px";
        move.x = move.y = 0;
    });
}

/* ---------- LOOK ---------- */
function initLook(){
    let active = false, px = 0, py = 0;

    document.addEventListener("pointerdown", e => {
        if(e.target.id === "shootBtn" || e.target.closest(".joystick")) return;
        active = true;
        px = e.clientX;
        py = e.clientY;
    });

    document.addEventListener("pointermove", e => {
        if(!active) return;
        look.x += (e.clientX - px) * 0.002;
        look.y += (e.clientY - py) * 0.002;
        px = e.clientX;
        py = e.clientY;
    });

    document.addEventListener("pointerup", () => active = false);
}

/* ---------- ENEMY ---------- */
function spawnEnemy(){
    const enemy = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.5, 1.2, 4, 8),
        new THREE.MeshStandardMaterial({ color: 0x7f1d1d })
    );
    enemy.position.set(
        (Math.random() - 0.5) * 60,
        1,
        (Math.random() - 0.5) * 60
    );
    enemy.userData.health = 100;
    scene.add(enemy);
    enemies.push(enemy);
}

/* ---------- SHOOT ---------- */
function shoot(){
    if(ammo <= 0) return;
    ammo--;
    ammoUI.textContent = ammo;

    raycaster.setFromCamera({ x: 0, y: 0 }, camera);
    const hits = raycaster.intersectObjects(enemies);

    if(hits.length){
        const e = hits[0].object;
        e.userData.health -= 40;
        e.material.color.set(0xff0000);

        if(e.userData.health <= 0){
            scene.remove(e);
            enemies = enemies.filter(x => x !== e);
        }
    }
}

/* ---------- LOOP ---------- */
let prev = performance.now();
function animate(){
    requestAnimationFrame(animate);
    const now = performance.now();
    const dt = (now - prev) / 1000;
    prev = now;

    camera.rotation.order = "YXZ";
    camera.rotation.y -= look.x;
    camera.rotation.x -= look.y;
    camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
    look.x *= 0.85;
    look.y *= 0.85;

    const dir = new THREE.Vector3(move.x, 0, move.y).applyEuler(camera.rotation);
    camera.position.addScaledVector(dir, dt * 6);

    enemies.forEach(e => {
        if(e.position.distanceTo(camera.position) < 18){
            e.lookAt(camera.position);
            e.position.add(
                e.getWorldDirection(new THREE.Vector3()).multiplyScalar(dt * 2)
            );
        }
    });

    renderer.render(scene, camera);
}
</script>
</body>
</html>
